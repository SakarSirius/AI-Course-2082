# -*- coding: utf-8 -*-
"""EDAproject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/107KaKaNAUWBB5mJuLy5xFboMnITJsOz0

#SuperStore Sales Dataset

Importing the Dataset
"""

from google.colab import drive
drive.mount('/content/drive')

"""Drive lai mount gareko"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
df = pd.read_csv("/content/drive/My Drive/train.csv")
df_copy=df.copy()

"""Yo code le upload gareko dataset colab vitra import garxa

#Data Quality Checks and Cleaning
"""

#Data Quality Checks and Cleaning
print(df.isnull().sum())
df_copy=df_copy.dropna(subset=['Postal Code'])
print(df_copy['Postal Code'].isnull().sum())
print("The duplicated values are:", df.duplicated().sum())
print(df_copy['Country'].nunique())
df_copy.drop(columns=['Country'], inplace=True)

"""Yo code le duplicate ra null values lai handle garxa

#Outlier Detection and Handling
"""

#Outlier Detection

#Boxplot for sales
sns.boxplot(df_copy['Sales'])
plt.title('Sales Boxplot')
plt.show()

"""Yo code le box plot bata outliers detect garna help garxa."""

#Remove outlier using interquartile method
# This part is standard and correctly calculates the
# first quartile, third quartile, and the Interquartile Range.
Q1 = df_copy['Sales'].quantile(0.25)
Q3 = df_copy['Sales'].quantile(0.75)
IQR = Q3 - Q1

# Calculating Lower and Upper Bounds:
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

df_copy1 = df.copy()    #Creating df_copy and filtering

df_copy1 = df_copy[(df_copy['Sales'] >= lower_bound) & (df_copy['Sales'] <= upper_bound)].copy()

sns.boxplot(df_copy1['Sales'])
plt.title('Sales Boxplot')
plt.show()

#Remove outlier using interquartile method
# This part is standard and correctly calculates the
# first quartile, third quartile, and the Interquartile Range.
Q1 = df_copy1['Sales'].quantile(0.25)
Q3 = df_copy1['Sales'].quantile(0.75)
IQR = Q3 - Q1

# Calculating Lower and Upper Bounds:
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

df_copy2 = df_copy1.copy()    #Creating df_copy and filtering

df_copy2 = df_copy1[(df_copy1['Sales'] >= lower_bound) & (df_copy1['Sales'] <= upper_bound)].copy()

sns.boxplot(df_copy2['Sales'])
plt.title('Sales Boxplot')
plt.show()

#Remove outlier using interquartile method
# This part is standard and correctly calculates the
# first quartile, third quartile, and the Interquartile Range.
Q1 = df_copy2['Sales'].quantile(0.25)
Q3 = df_copy2['Sales'].quantile(0.75)
IQR = Q3 - Q1

# Calculating Lower and Upper Bounds:
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

df_copy3 = df_copy2.copy()    #Creating df_copy and filtering

df_copy3 = df_copy2[(df_copy2['Sales'] >= lower_bound) & (df_copy2['Sales'] <= upper_bound)].copy()

sns.boxplot(df_copy3['Sales'])
plt.title('Sales Boxplot')
plt.show()

"""#Log Transformation"""

df_copy3['Sales_log'] = np.log1p(df_copy3['Sales'])  # log1p handles zero safely
sns.boxplot(y='Sales_log', data=df_copy3)

"""#Feature Engineering"""

#Feature Engineering
df['Order Date']= pd.to_datetime(df['Order Date'], format='mixed')
df['Order Year']= df['Order Date'].dt.year
df['Order Month']= df['Order Date'].dt.month
df['Order Day']= df['Order Date'].dt.day

"""Yo code le date vanne features bata day month ra year vanne naya feature banauxa

#Shipping Delay Feature
"""

#Shipping Delay Feature
df['Order Date']=pd.to_datetime(df['Order Date'], format='mixed')
df['Ship Date']=pd.to_datetime(df['Ship Date'], format='mixed')
df['Shipping Delay']= (df['Ship Date']- df['Order Date']).dt.days
df = df[df['Shipping Delay'] >= 0]
print(df[df['Shipping Delay'] < 0][['Order Date', 'Ship Date', 'Shipping Delay']])

"""Yo code le order date ra ship date ko features bata shipping delay vanne naya feature banauxa

#Visualization
"""

#Visualization
df.groupby('Order Month')['Sales'].sum().plot(kind='bar')
plt.ylabel('Total Sales')
plt.title('Total Sales by Month')
plt.show()
df.groupby('Order Year')['Sales'].sum().plot(kind='bar')
plt.ylabel('Total Sales')
plt.title('Total Sales by Year')
plt.show()

sns.countplot(x='Category', data=df)
plt.title("Total Sales by Category")
plt.xlabel("Category")
plt.ylabel("Sales")
plt.show()

"""Bivariate:Total sales by Category"""

sns.scatterplot(x='Category', y='Sales', data=df)
plt.title("Total sales by Category")
plt.xlabel("Category")
plt.ylabel("Sales")
plt.show()

"""Profit & Sales scatterplot"""

df["Profit"] = df["Sales"] * 0.1  # Assuming 10% profit margin
df.head(10)

sns.scatterplot(x='Sales', y='Profit', data=df)
plt.title("Estimated Profit vs. Sales")
plt.xlabel("Sales")
plt.ylabel("Profit")
plt.show()

"""Correlation Heatmap:"""

# Compute the correlation matrix (numeric columns only)

corr= df.corr(numeric_only=True)                     # True=Show correlation values
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt='.2f') # Format numbers to 2 decimal places
plt.title("Correlation Heatmap")                     #Values close to +1 → Strong positive,close to –1 → Strong negative,Values near 0 → Weak or no correlation
plt.show()

"""Distribution"""

sns.histplot(x='Segment', y='Profit', data=df)
plt.title("Estimated Profit vs. segment")   #histplot
plt.show()

"""
**Histplot with KDE **"""

sns.histplot(df['Profit'],kde=True)
plt.title('Distribution of Profit')   #KDE :smoothed Version
plt.show()

"""Violin Plot – Combines Distribution & Box Plot"""

sns.violinplot(x=df['Category'], y=df['Profit'])
plt.title('Profit Distribution by Product Category')
plt.xlabel('Category')
plt.ylabel('Profit')
plt.show()

"""Top 10 Repeat Customers"""

customer_freq = df['Customer Name'].value_counts()
plt.figure(figsize=(10, 6))
customer_freq.head(10).plot(kind='barh', color='skyblue')
plt.xlabel("Number of Purchases")
plt.ylabel("Customer Name")
plt.title("Top 10 Repeat Customers")
plt.show()

"""Top 10 Selling Products"""

product_freq = df['Product Name'].value_counts()
plt.figure(figsize=(10, 6))
product_freq.head(10).plot(kind='barh', color='orange')
plt.xlabel("Number of Times Purchased")
plt.ylabel("Product Name")
plt.title("Top 10 Most Frequently Purchased Products")
plt.show()

"""#Engineered Features Visualization"""

#Visualization of Shipping mode vs. Shipping Delay
plt.figure(figsize=(8,5))
sns.boxplot(x='Ship Mode', y='Shipping Delay', data=df)
plt.title('Shipping Delay by Ship Mode')
plt.show()

#Comparing delivery performance region wise
plt.figure(figsize=(8,5))
sns.barplot(x='Region', y='Shipping Delay', data=df, estimator='mean')
plt.title('Shipping Delay by Region')
plt.show()

#Visualizing shipping delays by order month
plt.figure(figsize=(10, 5))
sns.lineplot(x='Order Month', y='Shipping Delay', data=df, estimator='mean')
plt.title('Average Shipping Delay by Month')
plt.show()

#Visualizing Shipping Delay by customer segment
plt.figure(figsize=(8, 5))
sns.barplot(x='Segment', y='Shipping Delay', data=df, estimator='mean')
plt.title('Average Shipping Delay by Customer Segment')
plt.show()